untyped

global function CodeCallback_MapEditor

global function MapTriggers_Init

global function CreateMapEditorProp
global function MapEditorSpawnDoor
global function MapEditorCreateTrigger
global function MapEditorCreateBubbleShieldWithSettings
global function CreateRespawnableWeaponRack
global function CreateLinkedZipline

void function CodeCallback_MapEditor() // original script entry point
{
	MapTriggers_Init()
}

void function MapTriggers_Init()
{
	switch (GetMapName())
	{
		case "mp_rr_aqueduct_night":
		case "mp_rr_aqueduct":
		{
			CreateWallTrigger( <425, -1590, -1689>, 1, 30000 )
			CreateWallTrigger( <732, -4456, 840>, 2 , 6000)
			CreateWallTrigger( <774, -6394, 2067>, 0 )
			break
		}
		case "mp_rr_arena_skygarden":
		{
			CreateWallTrigger( <0, -250, 3490>, 0, 10000 )
			CreateWallTrigger( <0, -250, 3650>, 1, 20000 )
			CreateWallTrigger( <0, -250, 1550>, 1, 40000 )
			break
		}
		case "mp_rr_arena_composite":
		{
			CreateWallTrigger( <5, 2587, -520>, 1, 30000)
			CreateWallTrigger( <5, 5379, 860> , 0 )
			//CreateWallTrigger( <0, 5600, -190>, 85, true)
			//CreateWallTrigger( <0, 5600, -240>, 120)
			break
		}
		case "mp_rr_ashs_redemption":
		{
			CreateWallTrigger( <-20857, 5702, -25746> , 0 )
			break
		}
		case "mp_rr_party_crasher":
		{
			CreateWallTrigger( <811, 911, 2434>, 0 , 30000 )
    		CreateWallTrigger( <811, 911, -537>, 1 , 30000 )
			break
		}
		default:
			break
	}
}

entity function CreateWallTrigger( vector origin , int type = 0, float radius = 30000 , float Height = 2000, bool debugdraw = false)
{
	// Set up the trigger
    entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( radius )
	trigger.SetAboveHeight( Height )
	trigger.SetBelowHeight( 50 )
	trigger.SetOrigin( origin )
	trigger.SetEnterCallback(  WallTriggerEnter )

	switch(type)
	{
		case 1: // kill zone
		trigger.SetScriptName("WallTrigger_Killzone")
		trigger.SetAboveHeight( 350 )
		break
		case 2: // out of bounds
		trigger.SetScriptName("WallTrigger_oob_timer")
		trigger.SetAboveHeight( 2350 )
		break
	}

	if (debugdraw) // draw trigger bounds if needed
	{
		DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, trigger.GetAboveHeight(), 0, 165, 255, true, 9999.9 )
		DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, -trigger.GetBelowHeight(), 255, 90, 0, true, 9999.9 )
	}

	// deploy the trigger
    DispatchSpawn( trigger )

    return trigger
}

void function WallTriggerEnter( entity trigger , entity ent )
{
    if ( IsValid(ent) && ent.IsPlayer() && ent.GetPhysics() != MOVETYPE_NOCLIP) // ensure the entity is valid
    {
        ent.Zipline_Stop()

        switch( trigger.GetScriptName() )
        {
            case "WallTrigger_Killzone":
                ent.TakeDamage(ent.GetMaxHealth() + 1, null, null, { damageSourceId=damagedef_suicide, scriptType=DF_BYPASS_SHIELD })
            break

            case "WallTrigger_oob_timer":
                EntityOutOfBounds( trigger, ent, null, null )
            break

            default:
                vector lookDir = ent.GetSmoothedVelocity()
                vector pushBackVel = lookDir * 2.5

                if( LengthSqr( lookDir ) >= 320000)
                    pushBackVel = lookDir / 1.5

                vector targetDir = ent.GetWorldSpaceCenter() - trigger.GetWorldSpaceCenter()
                if ( DotProduct( lookDir, targetDir ) < 0 )
                    pushBackVel = -pushBackVel

                ent.KnockBack( pushBackVel, 0.3 )
                return
            break
        }

        ent.DisableWeapon()


        StatusEffect_AddEndless( ent, eStatusEffect.hunt_mode_visuals, 100 )
        StatusEffect_AddEndless( ent, eStatusEffect.move_slow, 0.2 )

        thread function() : ( trigger, ent )
        {
            while( IsValid(ent) && trigger.IsTouching( ent ) )
                WaitFrame()

            if( IsValid(ent) )
            {
                EntityBackInBounds( trigger, ent, null, null )
                ent.EnableWeapon()

                StatusEffect_StopAllOfType( ent, eStatusEffect.hunt_mode_visuals)
                StatusEffect_StopAllOfType( ent, eStatusEffect.minimap_jammed)
                StatusEffect_StopAllOfType( ent, eStatusEffect.move_slow)
            }
        }()
    }
}

entity function CreateMapEditorProp(asset a, vector pos, vector ang, bool mantle = false, float fade = 5000, int realm = -1, float scale = 1)
{
	entity e = CreatePropDynamic(a,pos,ang,SOLID_VPHYSICS,fade)
	e.kv.fadedist = fade
	e.kv.rendermode = 0
	e.kv.renderamt = 1
	e.kv.solid = 6
	e.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
	if(mantle) e.AllowMantle()
    
	if (realm > -1) {
		e.RemoveFromAllRealms()
		e.AddToRealm(realm)
	}
	string positionSerialized = pos.x.tostring() + "," + pos.y.tostring() + "," + pos.z.tostring()
	string anglesSerialized = ang.x.tostring() + "," + ang.y.tostring() + "," + ang.z.tostring()
    
	e.SetScriptName("editor_placed_prop")
	e.e.gameModeId = realm

    e.SetModelScale( scale )
    
	return e
}

void function MapEditorSpawnDoor(vector org, vector ang, int type, bool doubledoor = false, bool gold = false)
{
    if(type == 0)
    {
        if(doubledoor)
        {
            entity ddl = CreateEntity("prop_door")
            ddl.SetValueForModelKey($"mdl/door/canyonlands_door_single_02.rmdl")
            ddl.SetAngles(ang)
            ddl.SetOrigin(org + ddl.GetRightVector() * 60)
            if(gold)
                ddl.SetSkin( 1 )
            DispatchSpawn(ddl)

            entity ddr = CreateEntity("prop_door")
            ddr.SetValueForModelKey($"mdl/door/canyonlands_door_single_02.rmdl")
            ddr.SetAngles(ang + <0,180,0>)
            ddr.SetOrigin(org + ddr.GetRightVector() * 60)
            ddr.LinkToEnt( ddl )
            if(gold)
                ddr.SetSkin( 1 )
            DispatchSpawn(ddr)
        }
        else
        {
            entity singleDoor = CreateEntity("prop_door")
            singleDoor.SetValueForModelKey($"mdl/door/canyonlands_door_single_02.rmdl")
            singleDoor.SetOrigin(org)
            singleDoor.SetAngles(ang)
            if(gold)
                singleDoor.SetSkin( 1 )
            DispatchSpawn(singleDoor)
        }
    }
    else
    {
        entity singleDoor = CreateEntity("prop_dynamic")

        if(doubledoor)
            singleDoor.SetValueForModelKey($"mdl/door/door_256x256x8_elevatorstyle02_animated.rmdl")
        else
            singleDoor.SetValueForModelKey($"mdl/door/door_canyonlands_large_01_animated.rmdl")

        singleDoor.SetScriptName("survival_door_sliding")
        singleDoor.SetOrigin(org)
        singleDoor.SetAngles(ang)
        singleDoor.kv.solid = 6
        DispatchSpawn(singleDoor)
    }
}

entity function MapEditorCreateTrigger( vector origin, vector angles, float radius, float totalheight, bool debugdraw = false)
{
	// Set up the trigger
    entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( radius )
	trigger.SetAboveHeight( totalheight )
	trigger.SetBelowHeight( totalheight )
	trigger.SetOrigin( origin )
	trigger.SetAngles( angles )

	if (debugdraw) // draw trigger bounds if needed
	{
		DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, totalheight, 0, 165, 255, true, 9999.9 )
		DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, -totalheight, 255, 90, 0, true, 9999.9 )
	}

    return trigger
}

entity function MapEditorCreateBubbleShieldWithSettings( vector origin, vector angles, float scale, string color, asset collisionModel, bool fx = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( collisionModel ) // TODO: fix this for apex
	bubbleShield.kv.solid = SOLID_VPHYSICS
	bubbleShield.kv.rendercolor = color
	bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.SetModelScale( scale )
	// Blocks bullets, projectiles but not players and not AI
	bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
	DispatchSpawn( bubbleShield )

	if(fx)
	{
		array<entity> bubbleShieldFXs

		vector coloredFXOrigin = origin + Vector( 0, 0, 25 )
		table bubbleShieldDotS = expect table( bubbleShield.s )
		
		entity neutralColoredFX = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex(BUBBLE_BUNKER_SHIELD_FX), coloredFXOrigin, <0, 0, 0> )
		bubbleShieldDotS.neutralColoredFX <- neutralColoredFX
		bubbleShieldFXs.append( neutralColoredFX )
	}

	EmitSoundOnEntity( bubbleShield, "Gibraltar_BubbleShield_Sustain" )

	return bubbleShield
}

void function CreateRespawnableWeaponRack(vector pos, vector ang, string weaponName)
{
	entity rack = CreateWeaponRack(pos, ang, weaponName)
	thread OnPickupFromRackThread(GetWeaponFromRack(rack), weaponName)
}

// When the weapon is grabbed from the rack -> respawn it
void function OnPickupFromRackThread(entity item, string ref)
{
	entity rack = item.GetParent()
	item.WaitSignal("OnItemPickup")

	wait FIRINGRANGE_RACK_RESPAWN_TIME

	entity newWeapon = SpawnWeaponOnRack(rack, ref)
	StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), newWeapon.GetOrigin(), newWeapon.GetAngles() )
	thread OnPickupFromRackThread(newWeapon, ref)
}

entity function CreateZiplineNode(vector pos, string entitytype, string pointname, string NextKey, bool end)
{
    entity rope = CreateEntity( entitytype )
	SetTargetName( rope, pointname )
    
    if(!end)
        rope.kv.NextKey = NextKey

	rope.kv.MoveSpeed = 64
	rope.kv.Slack = 25
	rope.kv.Subdiv = "8"
	rope.kv.Width = "2"
	rope.kv.Type = "0"
	rope.kv.TextureScale = "1"
	rope.kv.RopeMaterial = "cable/zipline.vmt"
	rope.kv.PositionInterpolator = 2
	rope.kv.Zipline = "1"
	rope.kv.ZiplineAutoDetachDistance = "150"
	rope.kv.ZiplineSagEnable = "0"
	rope.kv.ZiplineSagHeight = "50"
	rope.SetOrigin( pos )

    return rope
}

void function CreateLinkedZipline( array<vector> points )
{
    array<entity> ziplineents
    array<string> ziplinesnames

    for(int i = 0; i < points.len(); i++) {
        string point = UniqueString( "rope_point_" + i )
        ziplinesnames.append(point)
    }

    foreach(int i, vector pos in points) {
        if(i == 0) {
            entity zipline = CreateZiplineNode(pos, "move_rope", ziplinesnames[i], ziplinesnames[i + 1], false)
            ziplineents.append(zipline)
        }
        else if(i < points.len() - 1) {
            entity zipline = CreateZiplineNode(pos, "keyframe_rope", ziplinesnames[i], ziplinesnames[i + 1], false)
            ziplineents.append(zipline)
        }
        else {
            entity zipline = CreateZiplineNode(pos, "keyframe_rope", ziplinesnames[i], "", true)
            ziplineents.append(zipline)
        }
    }

	foreach(entity ent in ziplineents) {
        DispatchSpawn( ent )
    }
}